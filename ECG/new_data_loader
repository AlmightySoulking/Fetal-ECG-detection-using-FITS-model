import os
import pyedflib
import numpy as np
import pandas as pd
from scipy.signal import butter, filtfilt, iirnotch, savgol_filter
from pywt import wavedec, waverec, threshold

class FetalRecord:
    def __init__(self, name, signal, labels, fs):
        self.name = name
        self.signal = signal
        self.labels = labels
        self.fs = fs

# ---------------- Preprocessing (adapted from Components_Extractor) ----------------
def _bandpass(x, lowcut=0.5, highcut=150.0, fs=1000.0, order=4):
    nyq = 0.5 * fs
    b, a = butter(order, [lowcut / nyq, highcut / nyq], btype='band')
    return filtfilt(b, a, x)

def _notch(x, notch_freq=50.0, q=30.0, fs=1000.0):
    b, a = iirnotch(notch_freq, q, fs)
    return filtfilt(b, a, x)

def preprocess_ecg(signal, fs):
    sig = np.asarray(signal, dtype=np.float64)
    sig = (sig - sig.mean()) / (sig.std() + 1e-8)
    sig = _bandpass(sig, 0.5, 150.0, fs)
    sig = _notch(sig, 50.0, 30.0, fs)
    sig = _notch(sig, 60.0, 30.0, fs)
    win = max(5, ((int(fs * 1.5)) // 2) * 2 + 1)
    baseline = savgol_filter(sig, window_length=win, polyorder=2)
    sig = sig - baseline
    coeffs = wavedec(sig, 'db4', level=5)
    for i in range(1, len(coeffs)):
        coeffs[i] = threshold(coeffs[i], np.std(coeffs[i]) * 0.1, mode='soft')
    sig = waverec(coeffs, 'db4')
    sig = sig[:len(baseline)]
    return sig.astype(np.float32)

# ---------------- Loader ----------------
class data_loader:
    def __init__(self, fs_fallback=1000):
        self.fs_fallback = fs_fallback

    def _parse_qrs(self, qrs_path):
        peaks = []
        if not os.path.exists(qrs_path):
            return np.array([], dtype=int)
        try:
            with open(qrs_path, 'r') as f:
                for line in f:
                    line = line.strip()
                    if not line:
                        continue
                    toks = line.replace(',', ' ').split()
                    for t in toks:
                        if t.isdigit():
                            peaks.append(int(t))
                            break
        except:
            return np.array([], dtype=int)
        return np.unique(np.array(peaks, dtype=int))

    def load_record(self, edf_path, channel=0, preprocess=True):
        if not edf_path.lower().endswith('.edf'):
            raise ValueError(f"Not an EDF file: {edf_path}")
        if not os.path.exists(edf_path):
            raise FileNotFoundError(edf_path)

        qrs_path = edf_path + '.qrs'
        alt_qrs = edf_path.replace('.edf', '.qrs')
        if not os.path.exists(qrs_path) and os.path.exists(alt_qrs):
            qrs_path = alt_qrs

        reader = pyedflib.EdfReader(edf_path)
        n_sig = reader.signals_in_file
        if channel >= n_sig:
            raise ValueError(f"Channel {channel} out of range (0..{n_sig-1})")
        sig = reader.readSignal(channel).astype(np.float32)
        try:
            fs = int(reader.getSampleFrequency(channel))
        except:
            fs = self.fs_fallback
        reader._close()

        peaks = self._parse_qrs(qrs_path)
        if preprocess:
            sig = preprocess_ecg(sig, fs)
        labels = np.zeros_like(sig, dtype=np.float32)
        if len(peaks) > 0:
            peaks = peaks[peaks < len(labels)]
            labels[peaks] = 1.0

        return FetalRecord(os.path.basename(edf_path), sig, labels, fs)

    def load_directory(self, directory, channel=0, preprocess=True):
        recs = []
        for fn in sorted(os.listdir(directory)):
            if fn.lower().endswith('.edf'):
                full = os.path.join(directory, fn)
                try:
                    recs.append(self.load_record(full, channel=channel, preprocess=preprocess))
                except Exception as e:
                    print(f"[WARN] skipping {fn}: {e}")
        return recs

    def windowize(self, record: FetalRecord, seq_len, stride):
        X, Y = [], []
        sig, lab = record.signal, record.labels
        for start in range(0, len(sig) - seq_len + 1, stride):
            end = start + seq_len
            X.append(sig[start:end])
            Y.append(lab[start:end])
        if not X:
            return np.empty((0, seq_len)), np.empty((0, seq_len))
        return np.stack(X), np.stack(Y)